<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" MadCap:lastBlockDepth="4" MadCap:lastHeight="3653" MadCap:lastWidth="887" MadCap:disableMasterStylesheet="true" MadCap:tocPath="The Query Monitor Tab" MadCap:InPreviewMode="false" MadCap:RuntimeFileType="Topic" MadCap:TargetType="WebHelp" MadCap:PathToHelpSystem="" MadCap:HelpSystemFileName="index.xml" MadCap:SearchType="Stem">
    <head><title>Query Profiling</title>
        <link href="resources/stylesheets/emc_help_stylesheet.css" rel="stylesheet" type="text/css" />
        <script src="SkinSupport/MadCapAll.js" type="text/javascript">
        </script>
    </head>
    <body>
        <h1 class="EMCHeadingLanding">Query Profiling</h1>
        <P>Pivotal Greenplum Database devises a query plan for each query it is given. Choosing the right query plan to match the query and data structure is absolutely critical for good performance. A query plan defines how the query will be executed in Greenplum Database's parallel execution environment. By examining the query plans of poorly performing queries, you can identify possible performance tuning opportunities.</P>
        <p>The query planner uses the database statistics it has to choose a query plan with the lowest possible cost. Cost is measured in disk I/O and CPU effort (shown as units of disk page fetches). The goal is to minimize the total execution cost for the plan.</p>
        <p>You can view the plan for a given query using the <code>EXPLAIN </code>command. This will show the query planner's estimated plan for the query. For example:</p>
        <P class="EMCSyntax"><b>EXPLAIN SELECT</b> * FROM names WHERE id=22;</P>
        <p><code>EXPLAIN ANALYZE</code> causes the statement to be actually executed, not only planned. This is useful for seeing whether the planner's estimates are close to reality. For example:</p>
        <P class="EMCSyntax"><b>EXPLAIN ANALYZE</b> SELECT * FROM names WHERE id=22;</P>
        <p class="EMCHeading1">Reading EXPLAIN Output</p>
        <p>Query plans are a tree plan of nodes. Each node in the plan represents a single operation, such as table scan, join, aggregation or a sort.</p>
        <p>Plans should be read from the bottom up as each node feeds rows into the node directly above it. The bottom nodes of a plan are usually table scan operations (sequential, index or bitmap index scans). If the query requires joins, aggregations, or sorts (or other operations on the raw rows) then there will be additional nodes above the scan nodes to perform these operations. The topmost plan nodes are usually the Greenplum Database motion nodes (redistribute, broadcast, explicit redistribute, or gather motions). These are the operations responsible for moving rows between the segment instances during query processing.</p>
        <p>The output of <code>EXPLAIN </code>has one line for each node in the plan tree, showing the basic node type plus the following cost estimates that the planner made for the execution of that plan node:</p>
        <ul>
            <li class="EMCBullet1" value="1"><code>cost </code>- Measured in units of disk page fetches; that is, 1.0 equals one sequential disk page read. The first estimate is the start-up cost (cost of getting to the first row) and the second is the total cost (cost of getting all rows). Note that the total cost assumes that all rows will be retrieved, which may not always be the case (if using <code>LIMIT </code>for example).</li>
            <li class="EMCBullet1" value="2"><code>rows </code>- The total number of rows output by this plan node. This is usually less than the actual number of rows processed or scanned by the plan node, reflecting the estimated selectivity of any <code>WHERE </code>clause conditions. Ideally the top-level nodes estimate will approximate the number of rows actually returned, updated, or deleted by the query.</li>
            <li class="EMCBullet1" value="3"><code>width </code>- Total bytes of all the rows output by this plan node.</li>
        </ul>
        <p>It is important to note that the cost of an upper-level node includes the cost of all its child nodes. The topmost node of the plan has the estimated total execution cost for the plan. This is this number that the planner seeks to minimize. It is also important to realize that the cost only reflects things that the query planner cares about. In particular, the cost does not consider the time spent transmitting result rows to the client.</p>
        <p class="EMCHeading2">EXPLAIN Example</p>
        <p>To illustrate how to read an <code>EXPLAIN </code>query plan, consider the following example for a very simple query:</p>
        <P class="EMCSyntax"> EXPLAIN SELECT * FROM names WHERE name = 'Joelle';<br /><br />QUERY PLAN<br />------------------------------------------------------------<br />Gather Motion 2:1 (slice1) (cost=0.00..20.88 rows=1 width=13)<br />-&gt; Seq Scan on 'names' (cost=0.00..20.88 rows=1 width=13)<br />Filter: name::text ~~ 'Joelle'::text</P>
        <p>If we read the plan from the bottom up, the query planner starts by doing a sequential scan of the <i>names</i> table. Notice that the <code>WHERE </code>clause is being applied as a <i>filter</i> condition. This means that the scan operation checks the condition for each row it scans, and outputs only the ones that pass the condition.</p>
        <p>The results of the scan operation are passed up to a <i>gather motion</i> operation. In Greenplum Database, a gather motion is when segments send rows up to the master. In this case we have 2 segment instances sending to 1 master instance (<code>2:1</code>). This operation is working on <i>slice1</i> of the parallel query execution plan. In Greenplum Database a query plan is divided into slices so that portions of the query plan can be worked on in parallel by the segments.</p>
        <p>The estimated startup cost for this plan is <code>00.00</code> (no cost) and a total cost of <code>20.88</code> disk page fetches. The planner is estimating that this query will return one row.</p>
        <p class="EMCHeading1">Reading EXPLAIN ANALYZE Output</p>
        <p><code>EXPLAIN ANALYZE</code> causes the statement to be actually executed, not only planned. The <code>EXPLAIN ANALYZE</code> plan shows the actual results along with the planner's estimates. This is useful for seeing whether the planner's estimates are close to reality. In addition to the information shown in the <code>EXPLAIN </code>plan, <code>EXPLAIN ANALYZE</code> will show the following additional information:</p>
        <ul>
            <li class="EMCBullet1" value="1">The total elapsed time (in milliseconds) that it took to run the query.</li>
            <li class="EMCBullet1" value="2">The number of <i>workers</i> (segments) involved in a plan node operation. Only segments that return rows are counted.</li>
            <li class="EMCBullet1" value="3">The maximum number of rows returned by the segment that produced the most rows for an operation. If multiple segments produce an equal number of rows, the one with the longest <i>time to end</i> is the one chosen.</li>
            <li class="EMCBullet1" value="4">The segment id number of the segment that produced the most rows for an operation.</li>
            <li class="EMCBullet1" value="5">For relevant operations, the <i>work_mem</i> used by the operation. If <code>work_mem </code>was not sufficient to perform the operation in memory, the plan will show how much data was spilled to disk and how many passes over the data were required for the lowest performing segment. For example:</li>
        </ul>
        <P class="EMCSyntax">Work_mem used: 64K bytes avg, 64K bytes max (seg0).<br />Work_mem wanted: 90K bytes avg, 90K bytes max (seg0) to abate workfile I/O affecting 2 workers.<br /><br />[seg0] pass 0: 488 groups made from 488 rows; 263 rows written to workfile<br />[seg0] pass 1: 263 groups made from 263 rows</P>
        <ul>
            <li class="EMCBullet1" value="1">The time (in milliseconds) it took to retrieve the first row from the segment that produced the most rows, and the total time taken to retrieve all rows from that segment. The &lt;<i>time</i>&gt; <i>to first row</i> may be omitted if it is the same as the &lt;<i>time</i>&gt;<i>to end</i>.</li>
        </ul>
        <p class="EMCHeading2">EXPLAIN ANALYZE Example</p>
        <p>To illustrate how to read an <code>EXPLAIN ANALYZE</code> query plan, we will use the same simple query we used in the <code>EXPLAIN </code>Example. Notice that there is some additional information in this plan that is not in a regular <code>EXPLAIN </code>plan. The parts of the plan in bold show the actual timing and rows returned for each plan node:</p>
        <P class="EMCSyntax">EXPLAIN ANALYZE SELECT * FROM names WHERE name = 'Joelle';<br /><br />QUERY PLAN<br />------------------------------------------------------------<br />Gather Motion 2:1 (slice1) (cost=0.00..20.88 rows=1 width=13)<br />recv: Total 1 rows with 0.305 ms to first row, 0.537 ms to end.<br />-&gt; Seq Scan on 'names' (cost=0.00..20.88 rows=1 width=13)<br />Total 1 rows (seg0) with 0.255 ms to first row, 0.486 ms to end.<br />Filter: name::text ~~ 'Joelle'::text<br />22.548 ms elapsed</P>
        <p>If we read the plan from the bottom up, you will see some additional information for each plan node operation. The total elapsed time it took to run this query was <code>22.548</code> milliseconds.</p>
        <p>The <i>sequential scan</i> operation had only one segment (<code>seg0</code>) that returned rows, and it returned just 1 row. It took <code>0.255</code> milliseconds to find the first row and <code>0.486</code> to scan all rows. Notice that this is pretty close to the planner's estimate - the query planner estimated that it would return one row for this query, which it did. The <i>gather motion</i> operation then received <code>1</code> row (segments sending up to the master). The total elapsed time for this operation was <code>0.537</code> milliseconds.</p>
        <p class="EMCHeading1">What to Look for in a Query Plan</p>
        <p>If a query is performing poorly, looking at its query plan can help identify problem areas. Here are some things to look for:</p>
        <ul>
            <li class="EMCBullet1" value="1">Is there one operation in the plan that is taking exceptionally long? When looking through the query plan, is there one operation that is consuming the majority of the query processing time? For example, here is a snippet of a node from an <code>EXPLAIN ANALYZE</code> plan. Most of the time of the query (about 20 minutes) was spent on this bitmap index scan operation. Why? Perhaps the index is out-of-date and needs to be re-indexed. You could also temporarily experiment with the <code>enable_ parameters</code> to see if you can force the planner to choose a different (and potentially better) plan.</li>
        </ul>
        <P class="EMCSyntax">Bitmap Index Scan on date_idx (cost=0.00..339096.56 rows=35712593 width=0)   Avg 35765315.83 rows x 6 workers. Max 35771652 rows (seg1) with 1190570 ms to end. <br /> Index Cond: ((date_id &gt;= 50720) AND (date_id &lt;= 60720))</P>
        <ul>
            <li class="EMCBullet1" value="1">Are the planner's estimates close to reality? Run an <code>EXPLAIN ANALYZE</code> and see if the number of rows estimated by the planner is close to the number of rows actually returned by the query operation. If there is a huge discrepancy, you may need to collect more statistics on the relevant columns. </li>
            <li class="EMCBullet1" value="2">Are selective predicates applied early in the plan? The most selective filters should be applied early in the plan so that less rows move up the plan tree. If the query plan is not doing a good job at estimating the selectivity of a query predicate, you may need to collect more statistics on the relevant columns. You can also try reordering the <code>WHERE </code>clause of your SQL statement.</li>
            <li class="EMCBullet1" value="3">Is the planner choosing the best join order? When you have a query that joins multiple tables, make sure that the planner is choosing the most selective join order. Joins that eliminate the largest number of rows should be done earlier in the plan so that less rows move up the plan tree. If the plan is not choosing the optimal join order, you can set <code>join_collapse_limit=1</code> and use explicit <code>JOIN </code>syntax in your SQL statement to force the planner to the specified join order. You can also collect more statistics on the relevant join columns. </li>
            <li class="EMCBullet1" value="4">Is the planner selectively scanning partitioned tables? If you are using table partitioning, is the planner selectively scanning only the child tables required to satisfy the query predicates? Do scans of the parent tables return 0 rows (they should, since the parent tables should not contain any data). </li>
            <li class="EMCBullet1" value="5">Is the planner choosing hash aggregate and hash join operations where applicable? Hash operations are typically much faster than other types of joins or aggregations. Row comparison and sorting is done in memory rather than reading/writing from disk. In order for hash operations to be chosen, there has to be sufficient work memory available to hold the number of estimated rows. Try increasing work memory to see if you can get better performance for a given query. If possible run an <code>EXPLAIN ANALYZE</code> for the query, which will show you which plan operations spilled to disk, how much work memory they used, and how much was required to not spill to disk. For example:</li>
        </ul>
        <P class="EMCSyntax">Work_mem used: 23430K bytes avg, 23430K bytes max (seg0).<br />Work_mem wanted: 33649K bytes avg, 33649K bytes max (seg0) to lessen workfile I/O affecting 2 workers.</P>
        <p class="EMCNote">The bytes wanted message from <code>EXPLAIN ANALYZE</code> is only a hint, based on the amount of data written to work files and is not exact. The minimum <code>work_mem</code> needed could be more or less than the suggested value.</p>
        <script type="text/javascript" src="SkinSupport/MadCapBodyEnd.js">
        </script>
    </body>
</html>